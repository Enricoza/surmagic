#!/usr/bin/env swift

//
//  surmagic
//
//  Created by Muhammed Gurhan Yerlikaya on 11.11.2020.
//  Copyright © 2020 https://github.com/gurhub/surmagic.
//

import Foundation

// MARK: - Main Logic

mainLogic()

// MARK: - Methods

/// Parse CommandLine "tool" and "options"
private func parseArguments() -> [(key: String, value: String)] {

    var options: [(key: String, value: String)] = []

    /// CommandTool
    if (CommandLine.argc > 1) {
        let tool = CommandLine.arguments[1]

        switch CommandTool(rawValue: tool) {
        case .initialize:
            createTemplateFiles()
            exit(1)
        case .xcf:
            break
        default:
            showHowToUseAndExit()
        }
    }

    /// CommandOption
    if (CommandLine.argc > 2) {

        let limit = CommandLine.argc-1

        for i in 2...limit {
            let arg = CommandLine.arguments[Int(i)]
            let components = getComponents(arg)

            switch CommandOptionKey(rawValue: components.key) {
            case .verbose:
                options.append(components)
            default:
                showWrongParameterWarningAndExit()
            }
        }
    }

    return options
}

/// Get Arguments
private func getComponents(_ argument: String?) -> (key: String, value: String) {
    guard let argument = argument else {
        return ("", "")
    }

    let components = argument.components(separatedBy: "=")

    if (components.count == 2) {
        let key = components[0].replacingOccurrences(of: "-", with: "")
        let value = components[1]

        return (key, value)
    } else {
        return ("", "")
    }
}

/// Process True or False from the String.
private func isTrue(_ value: String) -> Bool {
    guard let value = Bool(value) else {
        showWrongParameterWarningAndExit()
        return false
    }

    return value
}

/// Show wrong parameter warning and exit
private func showWrongParameterWarningAndExit() {
    let error = NSError(domain: "", code: 0,
                      userInfo: [NSLocalizedDescriptionKey : "Unknown option"])

    exit(with: error)
}

/// Prints how to use documentation and exits. 
private func showHowToUseAndExit() {
    let error = NSError(domain: "", code: 0,
                      userInfo: [NSLocalizedDescriptionKey : "Unknown argument call."])

    exit(with: error)
}

/// cp -a /source/. /dest/
/// Creates template files.
private func createTemplateFiles() {

    create("./Surmagic")

    let task = Process()
    task.executableURL = URL(fileURLWithPath: "/usr/bin/env")
    let source = "./Template/Surmagic/Surfile"
    task.arguments = ["cp", "-iv", source, "./Surmagic/."]
    
    do {
        try task.run()
        task.waitUntilExit()
        
        print(Colors.green + "\n 🚚 Initialized default files in the directory.\n" + Colors.reset)
    } catch {
        exit(with: nil)
    }
}

/// Removes files in giving directory.
private func remove(_ directory: String) {
    let task = Process()
    task.executableURL = URL(fileURLWithPath: "/usr/bin/env")
    task.arguments = ["rm", "-rf", directory]
    
    do {
        try task.run()
        task.waitUntilExit()
        
        print(Colors.green + "\n 🗑  Removed the directory: \(directory) \n" + Colors.reset)
    } catch {
        exit(with: nil)
    }
}

/// Creates a directory in giving directory.
private func create(_ directory: String) {
    let task = Process()
    task.executableURL = URL(fileURLWithPath: "/usr/bin/env")
    task.arguments = ["mkdir", directory]
    
    do {
        try task.run()
        task.waitUntilExit()
        
        print(Colors.green + "\n 📂 Created a directory: \(directory) \n" + Colors.reset)
    } catch {
        exit(with: nil)
    }
}

private func reset(_ directories: [String]) {
    for directory in directories {
        remove(directory)
        create(directory)
    }
}

private func archive(with target: Target, to directory: String, options: [(key: String, value: String)]) {
    let task = Process()
    task.executableURL = URL(fileURLWithPath: "/usr/bin/env")
    
    let archivePath = "./\(directory)/\(target.sdk).xcarchive"
    
    /// reset directories
    reset([archivePath])
    
    /// archive
    var arguments:[String] = [String]()
    arguments.append("xcodebuild")

    for option in options {
        switch CommandOptionKey(rawValue: option.key) {
        case .verbose:
            if !isTrue(option.value) {
                arguments.append("-quiet")
            }
        default:
            break
        }
    }
 
    arguments.append("archive")
    
    if let workspace = target.workspace {
        arguments.append("-workspace")
        arguments.append(workspace)
    } else if let project = target.project {
        arguments.append("-project \(project)")
        arguments.append(project)
    } else {
        print(Colors.red + "\n ⚠️ Missing parameter for the target. Please re-check the parameters below:\n \(target.desc) \n." + Colors.reset)
        // continue
        return
    }
    
    arguments.append("-sdk")

    if target.sdk == .macOSCatalyst {
        arguments.append(SDK.macOS.description)
    } else {
        arguments.append(target.sdk.description)
    }
    
    arguments.append("-scheme")
    arguments.append(target.scheme)
    
    arguments.append("-archivePath")
    arguments.append(archivePath)

    arguments.append("SKIP_INSTALL=NO")

    if target.sdk == .macOSCatalyst {
        arguments.append("SUPPORTS_MACCATALYST=YES")        
    }

    task.arguments = arguments
    
    print(Colors.yellow + "\n 📦 Archiving for the \(target.sdk) SDK.)" + Colors.reset)
    print(Colors.cyan + " 📝 : \n \(arguments))" + Colors.reset)
    
    do {
        try task.run()
        task.waitUntilExit()
        
        print(Colors.green + "\n 🎯 Archiving completed for the target: \(target.sdk) \n" + Colors.reset)
        
    } catch {
        exit(with: nil)
    }
}

private func archive(with targets: [Target], to directory: String, options: [(key: String, value: String)]) {
    for target in targets {
        archive(with: target, to: directory, options: options)
    }

    if targets.count > 0 {
        print(Colors.magenta + "\n ✅ Archive completed \(targets.count > 1 ? "for all targets" : "the target")." + Colors.reset)
    }
}

private func createXCFramework(with surfile: Surfile) {
    guard let targets = surfile.targets else { return }

    let directory = surfile.output_path
    let task = Process()
    task.executableURL = URL(fileURLWithPath: "/usr/bin/env")
     
    /// -archive
    var arguments:[String] = [String]()
    arguments.append("xcodebuild")
    arguments.append("-create-xcframework")
    
    /// -framework
    for target in targets {
        let archivePath = "./\(directory)/\(target.sdk).xcarchive"
        let path = archivePath + "/Products/Library/Frameworks/\(surfile.framework).framework"
        arguments.append("-framework")
        arguments.append(path)    
    }
    
    // Output
    let output = "./\(directory)/\(surfile.framework).xcframework"
    arguments.append("-output")
    arguments.append(output)
    
    task.arguments = arguments

    print(Colors.magenta + "\n 🏗  Creating a XCFramework.\n" + Colors.reset)
    print(Colors.cyan + " 📝 : \n \(arguments))" + Colors.reset)

    do {
        try task.run()
        task.waitUntilExit()
        
        print(Colors.green + "\n 🥳 Successfully created a XCFramework on the location: \(output)\n" + Colors.reset)

        /// clear archive paths
        for target in targets {
            let archivePath = "./\(directory)/\(target.sdk).xcarchive"
            remove(archivePath)
        }

        // Finaly open the output path
        openOutputPath(directory)
    } catch { 
        exit(with: nil)
    }
}

private func openOutputPath(_ directory: String) {
    let task = Process()
    task.executableURL = URL(fileURLWithPath: "/usr/bin/env")
     
    /// -archive
    var arguments:[String] = [String]()
    arguments.append("open")
    arguments.append(directory)
    
    task.arguments = arguments

    do {
        try task.run()
        task.waitUntilExit()
    } catch { 
        exit(with: nil)
    }
}

/// Parse the Surfile (plist) file for the parameters.
private func mainLogic() {
    do {
        let options = parseArguments()

        //let cwd = FileManager.default.currentDirectoryPath
        let path = "./Surmagic/Surfile"
        let plistURL = URL(fileURLWithPath: path)
        //_ = try String(contentsOfFile: plistURL.path, encoding: .utf8)
        //print(contents)
        
        let data = try Data(contentsOf: plistURL)
        let plistDecoder = PropertyListDecoder()
        let surfile: Surfile = try plistDecoder.decode(Surfile.self, from: data)
        print(surfile.desc)
        
        // Reset output direc
        let outputPath = "./\(surfile.output_path)"
        reset([outputPath])

        if let targets = surfile.targets {
            archive(with: targets, to: surfile.output_path, options: options)
            createXCFramework(with: surfile)
        } else {
            exit(with: nil)
        }
    } catch {
        exit(with: error)
    }
}

private func exit(with error: Error?) {
    let errorMessage: String

    if let error = error {
        errorMessage = "\(error.localizedDescription)"
    } else {
        errorMessage = "Code: 109."
    }

    print("❌ Error: \(errorMessage)")
    exit(1)
}

func yesOrNo(answer: String?) -> Bool {
    guard let answer = answer else {
        return true
    }

    if answer == "y" || answer == "yes" {
        return true
    } else if answer == "n" || answer == "no" {
        return false
    } else {
        return false
    }
}

// MARK: - CONSTANTS
// TODO: - Move to another file

struct Draw {
    static func topRow() {
        print(Colors.cyan + "\n\t##################################################################\n" + Colors.reset)
    }

    static func bottomRow() {
        print(Colors.cyan + "\n\t##################################################################\n" + Colors.reset)
    }

    static func stepSeperator() {
        print(Colors.cyan + "\n\t##################################################################\n" + Colors.reset)
    }
}

struct Colors {
    static let reset = "\u{001B}[0;0m"
    static let black = "\u{001B}[0;30m"
    static let red = "\u{001B}[0;31m"
    static let green = "\u{001B}[0;32m"
    static let yellow = "\u{001B}[0;33m"
    static let blue = "\u{001B}[0;34m"
    static let magenta = "\u{001B}[0;35m"
    static let cyan = "\u{001B}[0;36m"
    static let white = "\u{001B}[0;37m"
}

/*
<dict>
  <key>output_path</key>
  <string>_OUTPUT_DIRECTORY_NAME_HERE_</string>
  <key>framework</key>
  <string>_FRAMEWORK_NAME_HERE_</string>
  <key>targets</key>
  <array>
    <dict>
      <key>sdk</key>
      <string>_TARGET_OS_HERE_</string>
      <key>workspace</key>
      <string>_WORKSPACE_NAME_HERE_.xcworkspace</string>
      <key>scheme</key>
      <string>_SCHEME_NAME_HERE_</string>
    </dict>
  </array>
</dict>
 */
public class Surfile: Codable {
    
    // MARK: Properties
    
    /// output_path specifies the directory where any created archives will be placed, or the archive that should be exported. For a successful result .xcframework will be found in this directory.
    let output_path: String
    let framework: String
    let targets: [Target]?

    // MARK: Types
    enum CodingKeys: String, CodingKey {
        case output_path = "output_path"
        case framework = "framework"
        case targets = "targets"
    }
    
    public var desc: String {
        return ("output_path: \(String(output_path)) \n" +
                " framework: \(String(framework)) \n"
                )
    }
}

// MARK: - Enums

public enum SDK: String, Codable {
    case iOS
    case iOSSimulator
    case macOS
    case macOSCatalyst
    case tvOS
    case tvOSSimulator
    case watchOS
    case watchSimulator

    var description: String {
        switch self {
            case .iOS:            return "iphoneos"
            case .iOSSimulator:   return "iphonesimulator"
            case .macOS:          return "macosx"
            case .macOSCatalyst:  return "macOSCatalyst"
            case .tvOS:           return "appletvos"
            case .tvOSSimulator:  return "appletvsimulator"
            case .watchOS:        return "watchos"
            case .watchSimulator: return "watchsimulator"
        }
    }
}

/// surmagic [tool] --[option]=[value]
public enum CommandTool: String, Codable {
    case initialize = "init"
    case xcf        = "xcf"
    
    var description: String {
        switch self {
            case .initialize:           
                return "init"
            case .xcf:           
                return "xcf"
        }
    }
}

/// --[option]=[value]
public enum CommandOptionKey: String, Codable {
    case verbose = "verbose"
    
    var description: String {
        switch self {
            case .verbose:
                return "verbose"
        }
    }
}

/// --[option]=[value]
public enum CommandOptionValue: String, Codable {
    case notset = "notset"
    
    var description: String {
        switch self {
            case .notset:
                return "notset"
        }
    }
}

public class Target: Codable {

    // MARK: Types
    enum CodingKeys: String, CodingKey {
        case sdk = "sdk"
        case workspace = "workspace"
        case project = "project"
        case scheme = "scheme"
    }
    
    // MARK: Properties
    let sdk: SDK
    let workspace: String?
    let project: String?
    let scheme: String
    
    /// Description
    public var desc: String {
        return ("sdk: \(String(sdk.rawValue)) \n" +
                " workspace: \(String(workspace ?? "-")) \n" +
                " project: \(String(project ?? "-")) \n" +
                " scheme: \(String(scheme)) \n"
                )
    }
}